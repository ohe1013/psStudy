/*
    숫자놀이
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	128 MB	524	239	179	46.373%
문제
홀순이(holsoon)와 짝순이(jjaksoon) 둘이서 숫자 게임을 한다. 예를 들어, 정수 1과 3이 주어지고, 
이 둘을 통틀어 5번까지 마음대로 사용하여 그 합을 구하여 1,2,3,…을 만드는 놀이다.
 이 경우 먼저 홀순이가 1 하나만을 사용하여 1을 만든다. 
 짝순이는 1+1로 1을 두 번 사용하여 2를 만들고, 다시 홀순이는 3을 만들어야하는데 1+1+1로 1을 세 번 사용하거나
  3을 한 번 사용하여 3을 만든다. 짝순이는 1+1+1+1, 1+3으로 4를 만든다. 서로 번갈아서 상대방의 수보다 1이 큰 수를 만들어야 한다. 
  단, 1과 3을 통틀어 최대 5번 사용한다. 이런 식으로 진행하면 13까지는 만들 수 있지만 14를 만들지 못하게 되므로 짝순이가 졌다. 

숫자 게임에서 사용하는 정수 N개와 최대 사용 횟수 K가 주어질 때, 
누가 어느 수에서 이기는지를 판별하는 프로그램을 작성해보자. 
사용하는 정수에는 반드시 1이 포함된다. 그렇지 않으면 홀순이가 1을 만들지 못하므로 무조건 지게 된다. 
1이 꼭 있으니 상대방이 만든 방법에 1만 한 번 더 쓰면 된다고 생각하기 쉽지만, 최대 사용 횟수가 정해져 있으므로,
 이 방법이 수가 커지는 경우에는 잘 되지 않는다. 위에서 13을 홀순이가 만들었지만 짝순이는 최대 사용 횟수 
 때문에 14를 만들지 못하고 진다.

입력
첫째 줄에 숫자 게임에서 사용하는 정수의 수 N이, 둘째 줄에는 사용하는 정수가 크기 순으로 주어진다. 셋째 줄에는 최대 사용 횟수 K가 주어진다.

출력
첫째 줄에 누가 몇 번째 수에서 이겼는지를 출력한다. 예제에서는 짝순이가 14를 못 만들어서, 홀순이가 14에서 이겼다.

제한
1 ≤ N ≤ 1,000
1 ≤ K ≤ 50
숫자 게임에서 사용하는 정수는 1000보다 작거나 같은 자연수이고, 중복되는 수가 주어지지 않는다.
예제 입력 1 
2
1 3
5
holsoon win at 14

1 1/1 3 3/1 3/1/1 3/3 3/3/1 3/3/1/1 3/3/3 3/3/3/3/1
값이 1에서부터 커짐에 따라 무조건 적게 쓰는게 더 좋다.
최대로 만들 수 있는 값은 50000 최소는 1이다.
dp[value] = k 로 만드는형식을 띈다면
dp[14] = 6 이 될것이다. 그러면서 패배가 될 것이다.
좀 더 생각해보자 k는 늘어나면서 줄어드는 형식이된다.
여기선 1이 3개가 될때 3이되면서 k가 줄어든다.
1 2 1 2 3 2 3 4 3.. 이런식이다.
근데 이 경우는 N이 2인 경우이기 때문이다.
N이 5인 경우를 살펴보자.
1 3 4 5 7 이라는 값이 있다면,
1이 3개는 3으로 줄일 수 있고, 4가 될 때도 4로 한개로 줄여서 쓸 수 있다. 5도  7도 근데 예를들어 15일때 771도 가능하고 555도 가능하다
근데 이렇게 dp로 안풀고 그냥 k를 기준으로 보는 풀이는 불가능한가?
그냥 k개로 되는지 안되는지만 체크하면되지않나? 
14라는 값은 k개로 불가능한지만 알면되자나,

*/
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "example.txt";
const splitType = process.platform === "linux" ? "\n" : "\r\n";
let input = fs.readFileSync(filePath).toString().trim().split(splitType);

const N = parseInt(input.shift());

const valArr = input.shift().split(" ").map(Number);

const K = parseInt(input.shift());

const dp = new Array(50000).fill(Infinity);
valArr.forEach((val) => {
    dp[val] = 1;
});
dp[1] = 1;
for (let i = 2; i < 50000; i++) {
    valArr.forEach((val) => {
        if (val < i) {
            if (dp[i] > dp[i - val] + 1) dp[i] = dp[i - val] + 1;
        }
    });
}
const answer = dp.slice(1).findIndex((item) => item > K) + 1;

if (answer % 2 === 0) {
    console.log("holsoon win at " + answer);
} else {
    console.log("jjaksoon win at " + answer);
}
